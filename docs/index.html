<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VK3PGO FT8 Player</title>
    <link href="https://fonts.googleapis.com/css2?family=Jost:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #333333;
            --input-bg: #f0f0f0;
            --button-bg: #4CAF50;
            --button-text: #ffffff;

            --costas-bg: #a9a9a9;
            --data-bg: #737373;
            --ramp-bg: #d0d0d0;
        }

        .dark-mode {
            --bg-color: #222222;
            --text-color: #f0f0f0;
            --input-bg: #444444;
            --button-bg: #45a049;
            --button-text: #ffffff;

            --costas-bg: #545454;
            --data-bg: #1f1f1f;
            --ramp-bg: #333333;

            --link-color: #61dafb;
            --link-hover-color: #a8e9ff;
            --link-visited-color: #bb86fc;
        }

        body {
            font-family: 'Jost', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'Noto Sans', sans-serif, 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', 'Apple Color Emoji';
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            padding: 20px;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        h1, h2 {
            text-align: center;
        }

        .dark-mode a {
            color: var(--link-color);
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .dark-mode a:hover {
            color: var(--link-hover-color);
            text-decoration: underline;
        }

        .dark-mode a:visited {
            color: var(--link-visited-color);
        }

        input[type="text"], input[type="file"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            background-color: var(--input-bg);
            border: 1px solid var(--text-color);
            color: var(--text-color);
        }

        button {
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #visualization-caption {
            color: gray;
            font-size: 0.7em;
        }

        button:hover {
            opacity: 0.9;
        }

        #encode-output, #decode-output, #output {
            background-color: var(--input-bg);
            padding: 10px;
            margin-top: 10px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        #example-messages {
            margin-top: 20px;
        }

        #example-messages button {
            margin-right: 10px;
            margin-bottom: 10px;
        }

        #audio-controls {
            margin-top: 20px;
        }

        #audio-controls button {
            margin-right: 10px;
        }

        #theme-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
        }

        #piano-roll {
            margin-top: 20px;
            display: grid;
            gap: 1px;
            height: 100px;
            position: relative;
            background-color: var(--bg-color);
        }

        #piano-roll div {
            transition: background-color 0.1s;
        }

        #position-line {
            position: absolute;
            width: 2px;
            height: 100%;
            background-color: red;
            transition: left 0.1s;
        }

        body.dark-mode #piano-roll {
            background-color: #333;
        }

        body:not(.dark-mode) #piano-roll {
            background-color: #ddd;
        }

        #audio-visualization {
            margin-top: 20px;
        }
        #waveform-canvas {
            width: 100%;
            height: 200px;
            border: 1px solid #ccc;
        }
        #visualization-controls {
            margin-top: 10px;
        }
        #time-display {
            margin-left: 10px;
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            button {
                width: 100%;
                margin-bottom: 10px;
            }

            #theme-toggle {
                position: static;
                display: block;
                margin-bottom: 20px;
            }
        }
    </style>
</head>
<body class="dark-mode">
    <div class="container">
        <button id="theme-toggle">Toggle Dark Mode</button>
<!-- 
        <h1>FT8 Encoder/Decoder</h1> 
-->

        <h2>VK3PGO FT8 Player</h2>
        <input type="text" id="message-input" placeholder="Enter message to encode">
        <input type="number" id="base-freq-input" placeholder="Base frequency (Hz)" value="500">
        <button id="encode-button">Encode</button>
        <div id="audio-controls" style="display:none;">
            <button id="play-audio">Play Audio</button>
            <button id="play-audio-timed">Play at Next 15s Slot</button>
            <button id="stop-audio" disabled>Stop Audio</button>
            <button id="download-audio">Download Audio</button>
            <div id="countdown"></div>
        </div>

        <div id="piano-roll" style="margin-top: 20px;"></div>
        <div id="audio-visualization">
            <canvas id="waveform-canvas"></canvas>
            <div id="visualization-caption"></div>
            <div id="visualization-controls">
                <button id="toggle-visualization">Change Vizualization</button>
                <span id="time-display">0.00 / 0.00</span>
            </div>
        </div>
        <div id="output"></div>

        <div id="example-messages">
            <h3>Example Messages:</h3>
        </div>

        <div>
            Created by Pengo Wray. <br>
            Encoding library: FT8_lib. All processing is done on your device.
        <br>
        <br>
        <a href="https://github.com/pengowray/ft8play">
          <img src="https://img.shields.io/badge/View%20on-GitHub-brightgreen" alt="View on GitHub">
        </a>
        </div>

        <div style="display: none;">
            <h2>Decoder</h2>
            <input type="file" id="audio-input" accept=".wav">
            <button id="decode-button">Decode</button>
            <div id="decode-output"></div>
        </div>
    </div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="ft8_wasm.js"></script>
<script src="ft8_extra.js"></script>
<script>
    let audioData, dphiData, dphiSamples, currentTime = 0;
    let audioContext = null;
    let audioBuffer = null;
    let audioSource = null;
    let countdownInterval = null;
    let audioSamples;
    let metadata;
    let channelData;
    let baseFreq = 500;
    let sampleRate = 12000;

    const exampleMessages = [
        "CQ K1ABC FN42",
        "K1ABC W9XYZ -15",
        "W9XYZ K1ABC R-17",
        "K1ABC W9XYZ RRR",
        "W9XYZ K1ABC 73",
        "<TNX BOB 73 GL>"
    ];

    function initializeUI() {
        const encodeButton = document.getElementById('encode-button');
        const decodeButton = document.getElementById('decode-button'); // not used (yet)
        const messageInput = document.getElementById('message-input');
        const baseFreqInput = document.getElementById('base-freq-input');
        const audioInput = document.getElementById('audio-input');
        const encodeOutput = document.getElementById('output');
        const output = document.getElementById('output');
        //const decodeOutput = document.getElementById('decode-output');
        const audioControls = document.getElementById('audio-controls');
        const playAudioButton = document.getElementById('play-audio');
        const playAudioTimedButton = document.getElementById('play-audio-timed');
        const stopAudioButton = document.getElementById('stop-audio');
        const downloadAudioButton = document.getElementById('download-audio');
        const countdownDiv = document.getElementById('countdown');
        const themeToggle = document.getElementById('theme-toggle');
        const exampleMessagesDiv = document.getElementById('example-messages');

        const waveformCanvas = document.getElementById('waveform-canvas');
        waveformCanvas.width = waveformCanvas.clientWidth;
        waveformCanvas.height = 200;
        let waveformCtx = waveformCanvas.getContext('2d');

        const encodeFT8 = Module.cwrap('encodeFT8', 'number', ['string', 'number', 'number']);
        const freeFT8Result = Module.cwrap('freeFT8Result', null, ['number']);
        //const decodeFT8Symbols = Module.cwrap('decodeFT8Symbols', 'string', ['number', 'number']);
        //const decodeFT8PackedData = Module.cwrap('decodeFT8PackedData', 'string', ['number', 'number']);
        const decodeFT8Symbols = (symbolsPtr, length) => {
            const resultPtr = Module.ccall('decodeFT8Symbols', 'number', ['number', 'number'], [symbolsPtr, length]);
            if (resultPtr === 0) {
                console.error("Decoding failed");
                return null;
            }
            const result = Module.UTF8ToString(resultPtr);
            Module._free(resultPtr);
            return result;
        };
        const decodeFT8PackedData = (packedPtr, length) => {
            const resultPtr = Module.ccall('decodeFT8PackedData', 'number', ['number', 'number'], [packedPtr, length]);
            if (resultPtr === 0) return null;
            const result = Module.UTF8ToString(resultPtr);
            Module._free(resultPtr);
            return result;
        };

        function normalizeMessage(message) {
            return message.trim().toUpperCase().replace(/\s+/g, ' ');
        }

        function normalizeBracketedFreeText(input) {
            return input.trim().replace(/^<|>$/g, '');
        }
        function normalizeSymbols(input) {
            // numbers only
            return input.replace(/[-\s]/g, '');
        }

        function normalizeBinary(input) {
            // 0 and 1 only
            return input.replace(/[-\s]/g, '');
        }

        function normalizePackedData(input) {
            //return input.replace(/[-\s]/g, '').toUpperCase();
            return input.replace(/[-\s]/g, '').toLowerCase();
        }

        function normalizeTelemetry(str) {
            //exactly 18 hex digits, or start with T:
            //note: first digit must be 0-8 if 18 digits. (not checked here)
            let trimmed = str.trim();
            trimmed = trimmed.toUpperCase().replace(/^[Tt]:\s*/g, '');
            return trimmed;
        }
        function detectTelemetry(str) {
            //exactly 18 hex digits, or start with T:
            //note: first digit must be 0-8 if 18 digits. (not checked here)
            const trimmed = str.trim();
            return (/^[0-9A-Fa-f]{18}$/.test(trimmed)) || (/[Tt]:\s*[0-9A-Fa-f]{1,18}$/.test(trimmed))
        }

        function detectFreeTextBrackets(str) {
            const trimmed = str.trim();
            return (trimmed.startsWith('<') && trimmed.endsWith('>'));
        }

        function detectInputType(input) {
            input = input.trim();

            if (detectFreeTextBrackets(input)) {
                return 'free text';
            }

            if (/^[0-7]{79}$/.test(normalizeSymbols(input))) {
                return 'symbols';
            }
            // Check if input is hex string (packed data); pairs of hex must be together.
            if (/^\s*([0-9A-Fa-f]{2}[-\s]?){10}\s*$/.test(input)) {
                return 'packed';
            }

            if (detectTelemetry(input)) {
                return 'telemetry';
            }

            if (/^[0-1]{77}$/.test(normalizeBinary(input))) {
                return '77 bits'; // Source-encoded message, 77 bits
            }

            // Otherwise, assume it's a message (or 'free text' if ft8_lib fails to encode it)
            return 'message';
        }


        function updateOutput(result, inputType, originalInput) {
            
            const packedData = new Uint8Array(Module.HEAPU8.buffer, result.packed_data, result.packed_size);
            const symbols = new Uint8Array(Module.HEAPU8.buffer, result.symbols, result.symbol_count);

            output.innerHTML = '';
            if (inputType !== 'message') {
                output.innerHTML += `Input type: ${inputType}<br>`;
            }
            output.innerHTML += `Symbols: ${Array.from(symbols).join('')}<br>`;
            output.innerHTML += `Packed: ${packedToHexStrSp(packedData)}<br>`;

            const decodedSpan = document.createElement('span');
            decodedSpan.textContent = `Decoded: ${result.decoded_text}`;
            if (inputType === 'message' && normalizeMessage(result.decoded_text) !== normalizeMessage(originalInput)) {
                decodedSpan.style.color = 'red';
            }
            output.appendChild(decodedSpan);

            const messageInfo = FT8MessageTypeInfo(packedData);
            output.innerHTML += `<br>Message Type: ${messageInfo.messageType} (${messageInfo.type})`;
            output.innerHTML += `<br>Explanation: ${explainFT8Message(result.decoded_text, messageInfo)}<br>`;

            createPianoRoll(Array.from(symbols));
        }

        function createPianoRoll(symbols) {
            const pianoRollDiv = document.getElementById('piano-roll');
            pianoRollDiv.innerHTML = '';
            pianoRollDiv.style.gridTemplateColumns = `repeat(${symbols.length}, 1fr)`;

            symbols.forEach((symbol, index) => {
                const symbolDiv = document.createElement('div');
                symbolDiv.style.backgroundColor = getSymbolBackgroundColor(index);
                symbolDiv.style.gridRow = `${8 - symbol} / span 1`;
                symbolDiv.style.gridColumn = `${index + 1} / span 1`;
                symbolDiv.dataset.index = index;
                symbolDiv.dataset.symbol = symbol;
                pianoRollDiv.appendChild(symbolDiv);
            });

            const positionLine = document.createElement('div');
            positionLine.id = 'position-line';
            positionLine.style.display = 'none'; // Initially hidden
            pianoRollDiv.appendChild(positionLine);
        }

        function getSymbolBackgroundColor(index) {
            if (isCostasSymbol(index)) {
                return 'var(--costas-bg)';
            //} else if (isRampSymbol(index)) {
            //    return 'var(--ramp-bg)';
            } else {
                return 'var(--data-bg)';
            }
        }

        function isCostasSymbol(index) {
            const costasIndices = [0, 1, 2, 3, 4, 5, 6, 36, 37, 38, 39, 40, 41, 42, 72, 73, 74, 75, 76, 77, 78];
            return costasIndices.includes(index);
        }

        function isRampSymbol(index) {
            // FT8 doesn't have ramp symbols, but we'll keep this function in case of other modes
            return false;
        }

        function highlightCurrentSymbol(currentTime) {
            const symbolDuration = audioBuffer.duration / 79; // 79 symbols in FT8
            currentSymbolIndex = Math.floor(currentTime / symbolDuration);
            
            const pianoRollDiv = document.getElementById('piano-roll');
            const symbols = pianoRollDiv.children;
            const positionLine = document.getElementById('position-line');
            
            for (let i = 0; i < symbols.length; i++) {
                if (i === currentSymbolIndex) {
                    symbols[i].style.backgroundColor = getHighlightColor(symbols[i].dataset.symbol);
                } else {
                    symbols[i].style.backgroundColor = getSymbolBackgroundColor(i);
                }
            }

            // Update position line
            const progress = currentTime / audioBuffer.duration;
            positionLine.style.left = `${progress * 100}%`;
        }

        function getHighlightColor(symbol) {
            const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#5f27cd', '#ff6b6b', '#ff6b6b'];
            return colors[symbol];
        }

        function getHighlightColor(symbol) {
            const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#5f27cd', '#ff6b6b', '#ff6b6b'];
            return colors[symbol];
        }

        function stopAudio() {
            if (audioSource) {
                audioSource.stop();
                resetAudioState();
            }
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
                countdownDiv.style.display = 'none';
            }
            if (pianoRollInterval) {
                clearInterval(pianoRollInterval);
                pianoRollInterval = null;
            }
            updateButtonState(false);
        }

        function resetAudioState() {
            audioSource = null;
            updateButtonState(false);
            if (pianoRollInterval) {
                clearInterval(pianoRollInterval);
                pianoRollInterval = null;
            }
            // Hide position line
            const positionLine = document.getElementById('position-line');
            if (positionLine) {
                positionLine.style.display = 'none';
            }
            // Clear all highlights
            const pianoRollDiv = document.getElementById('piano-roll');
            const symbols = pianoRollDiv.children;
            for (let i = 0; i < symbols.length; i++) {
                symbols[i].style.backgroundColor = getSymbolBackgroundColor(i);
            }
        }

        function playAudio() {
            if (audioBuffer && !audioSource) {
                audioContext.resume().then(() => {
                    audioSource = audioContext.createBufferSource();
                    audioSource.buffer = audioBuffer;
                    audioSource.connect(audioContext.destination);
                    audioSource.start();
                    audioSource.onended = resetAudioState;
                    updateButtonState(true);

                    // Show position line
                    const positionLine = document.getElementById('position-line');
                    positionLine.style.display = 'block';
                    positionLine.style.backgroundColor = document.body.classList.contains('dark-mode') ? 'white' : 'red';

                    const startTime = audioContext.currentTime;
                    pianoRollInterval = setInterval(() => {
                        const currentTime = audioContext.currentTime - startTime;
                        drawWaveform(currentTime);
                        highlightCurrentSymbol(currentTime);
                        if (currentTime >= audioBuffer.duration) {
                            clearInterval(pianoRollInterval);
                            resetAudioState();
                        }
                    }, 50); // Update every 50ms
                });
            }
        }

        function updateButtonState(isPlaying) {
            playAudioButton.disabled = isPlaying;
            playAudioTimedButton.disabled = isPlaying;
            stopAudioButton.disabled = !isPlaying;
            downloadAudioButton.disabled = isPlaying;
        }

        function playAudioTimed() {
            if (audioBuffer && !audioSource) {
                const now = new Date();
                const secondsUntilNext15 = 15 - (now.getSeconds() % 15);
                let totalSeconds = secondsUntilNext15;

                updateButtonState(true);
                countdownDiv.style.display = 'block';

                function updateCountdown() {
                    const minutes = Math.floor(totalSeconds / 60);
                    const seconds = totalSeconds % 60;
                    countdownDiv.textContent = `Playing in ${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    if (totalSeconds <= 0) {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                        countdownDiv.style.display = 'none';
                        playAudio();
                    }
                    totalSeconds--;
                }

                updateCountdown(); // Call immediately to show correct time
                countdownInterval = setInterval(updateCountdown, 1000);
            }
        }

        playAudioButton.addEventListener('click', playAudio);
        playAudioTimedButton.addEventListener('click', playAudioTimed);
        stopAudioButton.addEventListener('click', stopAudio);
        downloadAudioButton.addEventListener('click', downloadAudio);

        function downloadAudio() {
            if (audioBuffer) {
                const wavData = audioBufferToWav(audioBuffer);
                const blob = new Blob([wavData], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                const baseFreq = parseFloat(baseFreqInput.value) || 1000;
                const message = messageInput.value.replace(/\s+/g, '_');
                a.download = `FT8-${baseFreq}Hz_${message}.wav`;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                }, 100);
            }
        }
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;

            let byteRate = sampleRate * numChannels * bitDepth / 8;
            let blockAlign = numChannels * bitDepth / 8;
            let dataSize = buffer.length * numChannels * bitDepth / 8;
            let headerSize = 44;
            let totalSize = headerSize + dataSize;

            let arrayBuffer = new ArrayBuffer(totalSize);
            let view = new DataView(arrayBuffer);

            // RIFF chunk descriptor
            writeString(view, 0, 'RIFF');
            view.setUint32(4, totalSize - 8, true);
            writeString(view, 8, 'WAVE');

            // FMT sub-chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // subchunk1size (16 for PCM)
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);

            // Data sub-chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            // Write the PCM samples
            let offset = 44;
            for (let i = 0; i < buffer.length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    let sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                    sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    view.setInt16(offset, sample, true);
                    offset += 2;
                }
            }

            return arrayBuffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function findMinAndMax(numbers) {
            let min = Infinity;
            let max = -Infinity;
            
            for (const num of numbers) {
                if (num < min) min = num;
                if (num > max) max = num;
            }
            
            return { min, max };
        }

        function scaleToRange(numbers, newMin, newMax) {
            const { min: originalMin, max: originalMax } = findMinAndMax(numbers);
            const scale = (newMax - newMin) / (originalMax - originalMin);
            
            return numbers.map(num => (num - originalMin) * scale + newMin);
        }

        messageInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                encodeButton.click();
            }
        });

        encodeButton.addEventListener('click', () => {
            try {
                let input = messageInput.value;
                let inputType = detectInputType(input);

                baseFreq = parseFloat(baseFreqInput.value) || 1000;
                sampleRate = parseInt(sampleRateSelect.value);
                        
                let resultPtr;
                if (inputType === 'free text') {
                    input = normalizeBracketedFreeText(input);
                    const packedData = encodeFT8FreeText(input);
                    const hexStr = packedToHexStr(packedData);
                    resultPtr = Module.ccall('processPackedHexStr', 'number', ['string', 'number', 'number'], [hexStr, baseFreq, sampleRate]);

                } else if (inputType === 'symbols') {
                    input = normalizeSymbols(input);
                    resultPtr = Module.ccall('processSymbols', 'number', ['string', 'number', 'number'], [input, baseFreq, sampleRate]);
                } else if (inputType === 'packed') {
                    if (typeof Module['_processPackedHexStr'] !== 'function') {
                        console.error('processPackedHexStr function not found in Module');
                        return;
                    }
                    input = normalizePackedData(input);
                    resultPtr = Module.ccall('processPackedHexStr', 'number', ['string', 'number', 'number'], [input, baseFreq, sampleRate]);

                } else if (inputType == 'telemetry') {
                    input = normalizeTelemetry(input);
                    let result = encodeFT8Telemetry(input);
                    if (result.error) {
                        output.innerHTML = result.error;
                        return;
                    } else {
                        resultPtr = Module.ccall('processPackedHexStr', 'number', ['string', 'number', 'number'], [result.result, baseFreq, sampleRate]);
                    }

                } else if (inputType === '77 bits') {
                    binaryStr = normalizeBinary(input);
                    input = binaryToHex(binaryStr);
                    resultPtr = Module.ccall('processPackedHexStr', 'number', ['string', 'number', 'number'], [input, baseFreq, sampleRate]);
                } else {
                    input = normalizeMessage(input);
                    resultPtr = Module.ccall('encodeFT8', 'number', ['string', 'number', 'number'], [input, baseFreq, sampleRate]);
                }

                if (inputType !== 'free text' && (!resultPtr || resultPtr === 0)) {
                    // attempt free text fallback
                    let textInput = input.trim();
                    if (textInput.length <= 13 && textInput.length > 0) {
                        try {
                            const packedData = encodeFT8FreeText(textInput);
                            const hexStr = packedToHexStr(packedData);
                            console.log("packedData", packedData);
                            resultPtr = Module.ccall('processPackedHexStr', 'number', ['string', 'number', 'number'], [hexStr, baseFreq, sampleRate]);
                            inputType = 'free text';
                        } catch (e) {
                             console.log("not free text", textInput, e)
                        }
                    }
                }

                if (resultPtr === 0) {
                    output.innerHTML = "Error: Invalid input";
                    return;
                }

                const result = {
                    packed_data: Module.getValue(resultPtr, '*'),
                    packed_size: Module.getValue(resultPtr + 4, 'i32'),
                    symbols: Module.getValue(resultPtr + 8, '*'),
                    symbol_count: Module.getValue(resultPtr + 12, 'i32'),
                    audio: Module.getValue(resultPtr + 16, '*'),
                    audio_samples: Module.getValue(resultPtr + 20, 'i32'),
                    dphi: Module.getValue(resultPtr + 24, '*'),
                    decoded_text: Module.UTF8ToString(Module.getValue(resultPtr + 28, '*')),
                    metadata: Module.UTF8ToString(Module.getValue(resultPtr + 32, '*')),
                    metadata_length: Module.getValue(resultPtr + 36, 'i32')
                };

                updateOutput(result, inputType, input);


                if (result.audio_samples > 0) {
                    audioSamples = new Float32Array(Module.HEAPF32.buffer, result.audio, result.audio_samples);
                    dphiSamples = new Float32Array(Module.HEAPF32.buffer, result.dphi, result.audio_samples);
                    
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: sampleRate });
                    audioBuffer = audioContext.createBuffer(1, result.audio_samples, sampleRate);
                    channelData = audioBuffer.getChannelData(0);
                    channelData.set(audioSamples);
                    
                    let range = findMinAndMax(dphiSamples);
                    dphiSamples = scaleToRange(dphiSamples, 190, 10) // fit in 0 to 200 (and flip?)

                    try {
                        metadata = JSON.parse(result.metadata);
                        console.log(metadata);

                    } catch (e) {
                        console.error("Error parsing metadata:", e);
                        metadata = {};
                    }

                    createWaveformVisualization(audioSamples, dphiSamples, metadata);

                    audioControls.style.display = 'block';
                    updateButtonState(false);
                    countdownDiv.style.display = 'none';
                } else {
                    console.error("No audio data generated");
                    output.textContent += "\nError: No audio data generated";
                    audioControls.style.display = 'none';
                }
            } catch (error) {
                    output.innerHTML = "Error: " + error.message;
            } finally {
                // Free the memory allocated in C
                Module.ccall('freeFT8Result', null, ['number'], [resultPtr]);
            }
        });

        exampleMessages.forEach(message => {
            const button = document.createElement('button');
            button.textContent = message;
            button.addEventListener('click', () => {
                messageInput.value = message;
                encodeButton.click();
            });
            exampleMessagesDiv.appendChild(button);
        });


        function FT8MessageTypeInfo(packedData) { 
            //packedData : Uint8Array(10)
            if (!packedData || packedData.length == 1 ) {
                return { messageType: "None", type: "-" };
            } else if ( packedData.length < 10) { 
                return { messageType: "Unknown", type: "-" };
            }

            const bytes = packedData;

            const i3 = (bytes[9] >> 3) & 0x07;
   
            switch (i3) {
                case 0:
                    const n3 = ((bytes[9] >> 6) & 0x03) | ((bytes[8] << 2) & 0x04); // bit[72] to bit[74] of end-padded 77-bit payload
                    switch (n3) {
                        case 0: return { type: "0.0", messageType: "Free text message" };
                        case 1: return { type: "0.1", messageType: "DXpedition mode" };
                        case 2: return { type: "0.2", messageType: "Unknown / Reserved" }; // EU VHF Contest ?
                        case 3: return { type: "0.3", messageType: "Field Day" };
                        case 4: return { type: "0.4", messageType: "Field Day" };
                        case 5: return { type: "0.5", messageType: "Telemetry" };
                        case 6: return { type: "0.6", messageType: "Unknown / Reserved" }; // Contesting ?
                        case 7: return { type: "0.7", messageType: "Unknown / Reserved" }; // Reserved for future use ?
                    }
                    break;
                case 1: return { type: "1", messageType: "Standard message" };
                case 2: return { type: "2", messageType: "EU VHF" };
                case 3: return { type: "3", messageType: "ARRL RTTY Roundup" }; // ARRL RTTY Roundup exchange ?
                case 4: return { type: "4", messageType: "Non-standard callsign" };
                case 5: return { type: "5", messageType: "Unknown / Reserved" }; // EU VHF contest with 6-digit grid locator ?
                case 6: return { type: "6", messageType: "Unknown / Reserved" };
                case 7: return { type: "7", messageType: "Unknown / Reserved" };
                default: return { type: `${i3}`, messageType: "Unknown" };
            }

            return { messageType: "Unknown", type: "-" };
        }

        function explainFT8Message(message, typeInfo) {
            if (message === "Decoding failed") {
                return '';
            }

            let typeExplanation = "";

            const parts = message.trim().split(/\s+/);
            let explanation = '';
            console.log(parts);

            function isSimpleCallsign(call) {
                return /^[A-Z0-9]{1,6}$/.test(call);
            }
            function isValidCallsign(call) {
                // at least one letter, one number, 3 to 15 characters, optional slash but not as first or last character
                return /[A-Z]/.test(call) && /[0-9]/.test(call) && /^[A-Z0-9][A-Z0-9\/]{1,13}[A-Z0-9]$/.test(call);
            }

            function isGridLocator(grid) {
                return /^[A-R]{2}[0-9]{2}([a-x]{2})?$/.test(grid);
            }

            function isReport(report) {
                return /^[+-]?\d{2}$/.test(report);
            }

            if (parts.length === 2 && parts[0] === 'CQ') {
                if (isValidCallsign(parts[1])) {
                    explanation = `This is a general call (CQ) message. Station ${parts[1]} is calling CQ, looking for any station to respond.`;
                } else {
                    explanation = `This is an unrecognized CQ message.`;
                }
            } else if (parts.length === 3 && parts[0] === 'CQ') {
                if (isValidCallsign(parts[1]) && isGridLocator(parts[2])) {
                    explanation = `This is a general call (CQ) message with location. Station ${parts[1]} is calling CQ from grid square ${parts[2]}, looking for any station to respond.`;
                } else if (/^[A-Z]{2}$/.test(parts[1]) && isValidCallsign(parts[2])) {
                    explanation = `This is a directed CQ message. Station ${parts[2]} is calling CQ, specifically looking for stations in the ${parts[1]} region to respond.`;
                } else {
                    explanation = `This is an unrecognized CQ message.`;
                }
            } else if (parts.length === 3 && isValidCallsign(parts[0]) && isValidCallsign(parts[1])) {
                if (isReport(parts[2])) {
                    explanation = `This is a signal report message. Station ${parts[0]} is sending a signal report of ${parts[2]} dB to station ${parts[1]}.`;
                    if (parts[2] === '73') { 
                        explanation += ' 73 is also shorthand for <i>best regards</i>.'
                    }
                } else if (parts[2] === 'RRR') {
                    explanation = `This is an acknowledgment message. Station ${parts[0]} is confirming receipt of information from station ${parts[1]}.`;
                } else if (parts[2] === 'RR73') {
                    explanation = `This is a combined acknowledgment and goodbye message. Station ${parts[0]} is confirming receipt and saying <i>best regards</i> to station ${parts[1]}.`;
                } else if (parts[2] === '73') {
                    explanation = `This is a goodbye message. Station ${parts[0]} is saying goodbye to station ${parts[1]} with "73" (best regards).`;
                } else if (isGridLocator(parts[2])) {
                    explanation = `Station ${parts[0]} is sending its grid locator ${parts[2]} to station ${parts[1]}.`;
                } else if (parts[2].startsWith('R')) {
                    explanation = `Station ${parts[0]} is acknowledging receipt of a message from ${parts[1]} and sending a signal report of ${parts[2].slice(1)} dB.`;
                } else {
                    explanation = `This is a message from ${parts[0]} to ${parts[1]}, but the content "${parts[2]}" is not recognized.`;
                }
            } else if (parts.length === 4 && isValidCallsign(parts[0]) && isValidCallsign(parts[1])) {
                if (parts[2] === 'R' && isReport(parts[3])) {
                    explanation = `This is a signal report acknowledgment. Station ${parts[0]} is confirming receipt of a previous message and sending a signal report of ${parts[3]} dB to station ${parts[1]}.`;
                } else {
                    explanation = `This is a message from ${parts[0]} to ${parts[1]}, but the content "${parts[2]} ${parts[3]}" is not recognized.`;
                }
            } else if (typeInfo.type === '0.0') { // || message.startsWith('<') && message.endsWith('>')) {
                explanation = `This is a free-text message: "${message}".`; // Free-text messages in FT8 are limited to 13 characters.
            } else if (typeInfo.type === '0.5') {
                explanation = `This is a telemetry message containing hexadecimal digits: ${message.replace(/^0*/g, '')}. The specific meaning depends on the implementation.`;
            } else if (/^[0-9A-F]{4,18}$/.test(message)) { 
                explanation = `This message is made up of hexadecimal digits, but it is not a telemetry message type.`;
            } else {
                explanation = '';
                //explanation = `This appears to be a custom or non-standard message: "${message}". It doesn't match common FT8 message formats.`;
            }

            return typeExplanation + explanation;
        }

        themeToggle.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            const positionLine = document.getElementById('position-line');
            if (positionLine) {
                positionLine.style.backgroundColor = document.body.classList.contains('dark-mode') ? 'white' : 'red';
            }
        });

        const sampleRateSelect = document.createElement('select');
        sampleRateSelect.id = 'sample-rate-select';
        [8000, 11025, 12000, 16000, 22050, 24000, 44100, 48000].forEach(rate => {
            const option = document.createElement('option');
            option.value = rate;
            option.textContent = `${rate} Hz`;
            if (rate === 12000) option.selected = true;
            sampleRateSelect.appendChild(option);
        });
        baseFreqInput.parentNode.insertBefore(sampleRateSelect, baseFreqInput.nextSibling);

        function createWaveformVisualization(audioSamples, dphiSamples, metadata) {
            audioData = audioSamples;
            dphiData = dphiSamples;
            sampleRate = metadata?.sample_rate ?? 12000;

            // Set canvas size
            waveformCanvas.width = waveformCanvas.clientWidth;
            waveformCanvas.height = 200;

            // Initial draw
            drawWaveform();
        }

        function handleResize() {
            if (waveformCanvas) {
                waveformCanvas.width = waveformCanvas.clientWidth;
                drawWaveform();
            }
        }

        window.addEventListener('resize', handleResize);

        const showModes = [ 
            {name: "Off", "mode": "off", "zoom": 1}, 
            {name: "Frequency Deviation", "mode": "dphi", "zoom": 1},  // aka "Unmodulated", or "frequency deviation waveform generated using the Gaussian smoothed frequency deviation pulse"
            {name: "Frequency Deviation (zoom)", "mode": "dphi", "zoom": 16}, 
            {name: "Waveform", "mode": "wave", "zoom": 256},
            {name: "Oscilloscope", "mode": "wave", "zoom": 2048},
        ];
        let showMode = 0;
        const toggleVisualizationButton = document.getElementById('toggle-visualization');
        const VisualizationCaption = document.getElementById('visualization-caption');
        function toggleVisualization() { // todo: rename cycleVisualization
            showMode = (showMode + 1) % showModes.length;
            //showDphi = !showDphi;
            VisualizationCaption.innerHTML = showModes[showMode]['name'];
            drawWaveform();
        }
        toggleVisualization(); // set name on button (and turn on viz)

        toggleVisualizationButton.addEventListener('click', toggleVisualization);

        function drawWaveform(currentTime = 0) {
            const mode = showModes[showMode];
            const showDphi = (mode['mode'] === 'dphi');
            const off = (mode['mode'] === 'off');

            if (!waveformCanvas) return;

            const width = waveformCanvas.width;
            const height = waveformCanvas.height;
            const middle = height / 2;
            waveformCtx.clearRect(0, 0, width, height);

            if (off) return;

            waveformCtx.beginPath();
            waveformCtx.moveTo(0, middle);

            const zoomLevel = mode['zoom'];

            const data = showDphi ? dphiData : audioData;
            if (!data || data.length === 0) {
                console.error(`No ${showDphi ? 'dphiData' : 'audioData'} to draw`);
                return;
            }

            const totalDuration = data.length / sampleRate;
            const visibleDuration = totalDuration / zoomLevel;
            const samplesPerPixel = (sampleRate * visibleDuration) / width;

            let startTime = currentTime - visibleDuration / 2;
            let endTime = currentTime + visibleDuration / 2;

            // Adjust start and end times to prevent showing blank areas
            if (startTime < 0) {
                startTime = 0;
                endTime = visibleDuration;
            } else if (endTime > totalDuration) {
                endTime = totalDuration;
                startTime = endTime - visibleDuration;
            }

            let startSample = Math.floor(startTime * sampleRate);
            let endSample = Math.floor(endTime * sampleRate);

            // Implement trigger-like behavior for high zoom levels
            if (!showDphi && zoomLevel > 2000) {
                const triggerWindowSamples = Math.floor(sampleRate * 0.01); // 0.001 = 1ms window (todo: consider actual data)
                //const triggerThreshold = 0.1;
                
                for (let i = startSample; i < startSample + triggerWindowSamples; i++) {
                    if (i + 1 < data.length) {
                        if (data[i] <= 0 && data[i + 1] > 0) {
                            // || (Math.abs(data[i]) < triggerThreshold && Math.abs(data[i + 1]) >= triggerThreshold)) {

                            //todo: should probably do some of these calcs in samples instead of time, but matching earlier calcs
                            let newStartSample = i;
                            let newEndTime = (i / sampleRate) + visibleDuration;
                            if (endTime > totalDuration) {
                                break; // trigger is too late, ignore
                                //endTime = totalDuration;
                                //startTime = endTime - (visibleDuration / sampleRate);
                                //startSample = Math.floor(startTime * sampleRate); 
                            }

                            startSample = newStartSample;
                            endSample = Math.floor(newEndTime * sampleRate);
                            break;
                        }
                    }
                }
            }

            waveformCtx.beginPath();
            waveformCtx.moveTo(0, middle);

            let lastX = -1;
            for (let sample = startSample; sample <= endSample; sample++) {
                if (sample >= 0 && sample < data.length) {
                    const x = Math.floor((sample - startSample) / samplesPerPixel);
                    if (x !== lastX) {
                        let y;
                        if (showDphi) {
                            y = data[sample]; // pre-scaled
                        } else {
                            y = middle + (data[sample] * middle * 0.9);
                        }
                        waveformCtx.lineTo(x, y);
                        lastX = x;
                    }
                }
            }

            waveformCtx.strokeStyle = showDphi ? 'green' : 'steelblue';
            waveformCtx.stroke();

            // Draw playback position line
            const playbackX = ((currentTime - startTime) / visibleDuration) * width;
            waveformCtx.beginPath();
            waveformCtx.moveTo(playbackX, 0);
            waveformCtx.lineTo(playbackX, height);
            waveformCtx.strokeStyle = 'red';
            waveformCtx.stroke();

            // Update time display
            const timeDisplay = document.getElementById('time-display');
            timeDisplay.textContent = `${currentTime.toFixed(2)} / ${totalDuration.toFixed(2)}`;
        }
    }

    if (typeof Module !== 'undefined') {
        Module.onRuntimeInitialized = initializeUI;
    } else {
        document.addEventListener('DOMContentLoaded', initializeUI);
    }
</script>
</body>
</html>
